# Skills - 质量类

本文档包含 4 个质量相关的 Skills：
- verification
- tdd
- code-review
- debugging

> **执行模式**：质量类 Skills 通常由其他 Skills（如 deliver-ticket）自动调用，作为自动执行流程的一部分。这些 Skills 遵循「证据先于断言」原则，所有验证结果必须有命令输出证明。

---

## 1. verification

**参考来源**：obra/superpowers verification-before-completion

```yaml
---
name: verification
description: "Use when completing any task or making success claims - enforces evidence before assertions"
invoked_by: agent
---
```

### 铁律

```
NO COMPLETION CLAIMS WITHOUT FRESH VERIFICATION EVIDENCE
```

**如果你没有在此消息中运行验证命令，你不能声称它通过。**

### 门控函数

在声明任何状态或表达满意之前，**必须**执行：

```
1. IDENTIFY: 什么命令证明这个声明？
2. RUN: 执行完整命令（新鲜、完整）
3. READ: 完整输出，检查退出码，统计失败
4. VERIFY: 输出是否确认声明？
   - 如果 NO: 用证据说明实际状态
   - 如果 YES: 用证据说明声明
5. ONLY THEN: 做出声明

跳过任何步骤 = 撒谎，不是验证
```

### 常见失败对照表

| 声明 | 需要的证据 | 不够的证据 |
|------|-----------|-----------|
| "测试通过" | 测试命令输出: 0 失败 | 之前的运行、"应该通过" |
| "Linter 干净" | Linter 输出: 0 错误 | 部分检查、推断 |
| "构建成功" | 构建命令: exit 0 | Linter 通过、日志看起来好 |
| "Bug 修好了" | 测试原症状: 通过 | 代码改了，假设修好了 |
| "回归测试工作" | Red-green 循环验证 | 测试通过一次 |
| "需求满足" | 逐行检查清单 | 测试通过 |

### 反合理化表格

| 借口 | 现实 |
|------|------|
| "应该现在工作了" | 运行验证 |
| "我很有信心" | 信心 ≠ 证据 |
| "就这一次" | 无例外 |
| "Linter 通过了" | Linter ≠ 编译器 |
| "代理说成功了" | 独立验证 |
| "我累了" | 疲惫 ≠ 借口 |
| "部分检查就够了" | 部分证明不了什么 |
| "不同措辞所以规则不适用" | 精神胜过文字 |

### 红旗 - 立即停止

发现以下任何情况，**停止并运行验证**：

- 使用"应该"、"可能"、"似乎"
- 在验证前表达满意（"Great!"、"Perfect!"、"Done!"）
- 即将提交/推送/PR 而没有验证
- 信任代理成功报告
- 依赖部分验证
- 想"就这一次"
- 累了想要工作结束
- 任何暗示成功而没有运行验证的措辞

### 验证清单

- [ ] 测试通过（命令输出）
- [ ] Lint 通过（命令输出）
- [ ] 功能可用（如有 UI，截图证明）

### ⚠️ 校验维度矩阵（重要）

**任何校验都必须覆盖以下所有维度，不能只检查"想到的"：**

```yaml
校验维度矩阵:
  # 第一层：结构一致性
  结构层:
    - 数字一致性: "Skills、Agents、命令、模板的数量"
    - 导航一致性: "目录表格、相关文档链接"
    - 目录一致性: "文件结构、路径引用"
    - 链接完整性: "内部链接无断链"
  
  # 第二层：格式一致性
  格式层:
    - ID 格式: "REQ-xxx、S-xxx、T-xxx、CP-xxx"
    - 时间格式: "ISO 8601 UTC"
    - 路径格式: "相对路径、allowed_paths"
    - 代码格式: "代码块闭合、语言标识"
  
  # 第三层：语义一致性（易遗漏！）
  语义层:
    - 技术栈版本: "从 config.yaml 读取，检查代码是否匹配配置"
    - 配置值: "从 config.yaml 读取，检查引用是否一致"
    - 业务术语: "角色名、模块名、状态名是否统一"
    - 示例数据: "示例中的 ID、名称、路径是否合理"
  
  # 第四层：逻辑一致性
  逻辑层:
    - 流程完整: "所有分支都有处理"
    - 依赖正确: "A 依赖 B，B 必须先定义"
    - 条件互斥: "if/else 条件不重叠"
    - 边界处理: "空值、极端值、错误情况"
```

**校验规则**：
1. **每个维度都必须检查** - 不能只检查"想到的"
2. **换样提问** - 从不同角度反复检查同一内容
3. **无轮次限制** - 直到所有维度都无修改才结束
4. **修改触发重检** - 任何修改都要重新检查所有维度

### Prompt 模板

```markdown
# Verification Skill

## 铁律
**NO COMPLETION CLAIMS WITHOUT FRESH VERIFICATION EVIDENCE**

## 核心原则
**证据先于断言**：所有完成声明必须有命令输出证明。

## 门控函数（每次验证前执行）

1. IDENTIFY: 什么命令证明这个声明？
2. RUN: 执行完整命令
3. READ: 完整输出，检查退出码
4. VERIFY: 输出是否确认声明？
5. ONLY THEN: 做出声明

## 验证流程

### Step 1: 执行验证命令
运行 Ticket 中定义的所有 acceptance 检查：

```yaml
acceptance:
  - type: command
    run: "mvn test -Dtest=SysUserControllerTest"
    expect: "BUILD SUCCESS"
  - type: command
    run: "mvn checkstyle:check"
    expect: "BUILD SUCCESS"
```

### Step 2: 收集证据
"""
## 🔍 验证证据

### 测试结果
命令: `mvn test -Dtest=SysUserControllerTest`
```
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0
[INFO] BUILD SUCCESS
```
✅ 通过

### Lint 结果
命令: `mvn checkstyle:check`
```
[INFO] BUILD SUCCESS
```
✅ 通过

### 功能验证
{如适用，附截图或 API 响应}
"""

### Step 3: 输出验证报告
"""
## ✅ 验证完成

| 检查项 | 状态 | 证据 |
|--------|------|------|
| 单元测试 | ✅ | 3 tests passed |
| 代码规范 | ✅ | checkstyle passed |
| 功能可用 | ✅ | API 返回 200 |

**结论**: 验收通过
"""

## 硬性约束
1. 必须执行所有 acceptance 检查
2. 必须展示命令输出作为证据
3. 任何检查失败则整体不通过
4. 不接受"应该没问题"的主观判断
5. **跳过门控函数的任何步骤 = 违反铁律**
```

---

## 2. tdd

**参考来源**：obra/superpowers test-driven-development

```yaml
---
name: tdd
description: "Use when implementing any feature - enforces test-first development with red-green-refactor cycle"
invoked_by: agent
---
```

### 铁律

```
NO PRODUCTION CODE WITHOUT A FAILING TEST FIRST
```

**违反铁律 = 违反精神**

如果先写了代码再写测试：
1. **删除代码**
2. **不要保留作为"参考"**
3. **从测试开始，重新实现**

### 反合理化表格

| 借口 | 现实 |
|------|------|
| "太简单不用测试" | 简单代码也会坏。测试只需 30 秒。 |
| "我之后写测试" | 事后写的测试通过不能证明任何事。 |
| "测试后达到相同目标" | 测试后 = "这做什么？" 测试先 = "这应该做什么？" |
| "已经手动测试了" | 临时 ≠ 系统化。无记录，无法重跑。 |
| "删掉 X 小时的工作太浪费了" | 沉没成本谬误。保留不可信的代码才是技术债。 |
| "保留作为参考，先写测试" | 你会去适配它。这就是事后测试。删除就是删除。 |
| "需要先探索" | 可以。扔掉探索，用 TDD 开始。 |
| "测试难 = 设计不清楚" | 听测试的。难测试 = 难用。 |
| "TDD 会慢下来" | TDD 比调试快。务实 = 测试先。 |
| "手动测试更快" | 手动不证明边界情况。每次变更都要重测。 |

### 红旗 - 停止并重新开始

如果发现以下任何情况，**停止，删除代码，重新开始**：

- 代码在测试之前
- 测试在实现之后
- 测试立即通过（没有红灯阶段）
- 无法解释为什么测试失败
- 测试"稍后"添加
- 合理化"就这一次"
- "我已经手动测试了"
- "保留作为参考"或"适配现有代码"
- "已经花了 X 小时，删除太浪费"
- "TDD 太教条，我要务实"
- "这次不同因为..."

**所有这些都意味着：删除代码。用 TDD 重新开始。**

### 配置选项（我们的独特优势：降级策略）

> **重要**：降级策略是针对低测试覆盖率的遗留项目（如若依）的现实妥协，但必须显式标注。

```yaml
# project/config.yaml 中的 TDD 配置
tdd:
  strict_mode: false  # true = 严格 TDD，false = 允许降级
  
  # 降级条件（当 strict_mode: false 时）
  fallback_conditions:
    - existing_coverage_low: true      # 现有测试覆盖率低于 20%
    - no_test_infrastructure: true     # 缺少测试框架配置
    - legacy_code_modification: true   # 修改遗留代码
  
  # 降级时的替代验证
  fallback_verification:
    - "lint_pass"      # Lint 必须通过
    - "build_pass"     # 构建必须通过
    - "manual_test"    # 需要手动测试说明
```

### 降级策略

当项目不适合严格 TDD（如若依这类现有测试覆盖率低的项目）时：

| 场景 | 处理方式 |
|------|----------|
| 新增独立功能 | **尽量 TDD**（铁律仍适用） |
| 修改现有代码 | 先补测试，再修改 |
| 现有代码无测试 | 使用 lint + build + 手动验证 |
| 紧急修复 | 可跳过，但必须记录技术债 |

**降级时必须**：
1. 在 Ticket 日志中标注 `tdd_skipped: true` 和原因
2. 确保 lint 和 build 通过
3. 提供手动测试步骤
4. **记录技术债**：`osg-spec-docs/tasks/tech-debt.yaml`

### TDD 流程

1. **红**：先写失败的测试
2. **绿**：写最少代码让测试通过
3. **重构**：优化代码，保持测试通过

### Prompt 模板

```markdown
# TDD Skill

## 铁律
**NO PRODUCTION CODE WITHOUT A FAILING TEST FIRST**

违反铁律 → 删除代码 → 重新开始

## 核心原则
**测试先行**：在写实现代码之前，必须先写测试。

## TDD 循环

### Phase 1: 红灯 🔴
1. 根据需求编写测试用例
2. **运行测试，确认失败**
3. **验证失败原因是"缺少功能"，不是拼写错误**
4. 输出：
"""
### 🔴 红灯阶段

**测试文件**: {test_file}

**测试用例**:
```java
@Test
public void testListUsers_success() {
    // 测试代码
}
```

**运行结果**:
```
Tests run: 1, Failures: 1, Errors: 0
FAILED: testListUsers_success
Expected: not null
Actual: null
```

✅ 红灯确认：测试因**缺少功能**而失败（不是拼写错误）
"""

**测试立即通过？** 你在测试现有行为。修复测试。
**测试错误？** 修复错误，重新运行直到正确失败。

### Phase 2: 绿灯 🟢
1. 编写**最少的**实现代码
2. **不要**添加额外功能、重构其他代码、"改进"超出测试范围
3. 运行测试，确认通过
4. 输出：
"""
### 🟢 绿灯阶段

**实现文件**: {impl_file}

**关键代码**:
```java
public List<SysUser> selectUserList(SysUser user) {
    return userMapper.selectUserList(user);
}
```

**运行结果**:
```
Tests run: 1, Failures: 0, Errors: 0
BUILD SUCCESS
```

✅ 绿灯确认：测试通过
"""

**测试失败？** 修复代码，不是测试。
**其他测试失败？** 现在修复。

### Phase 3: 重构 🔄
1. **仅在绿色之后**：移除重复、改进名称、提取辅助函数
2. 保持测试绿色，**不要添加行为**
3. 输出：
"""
### 🔄 重构阶段

**优化内容**: {优化说明，如无则标注"无需重构"}

**验证结果**:
```
Tests run: 1, Failures: 0, Errors: 0
BUILD SUCCESS
```

✅ 重构完成：测试仍然通过
"""

## 验证清单

在标记工作完成前：

- [ ] 每个新函数/方法都有测试
- [ ] 在实现前看到每个测试失败
- [ ] 每个测试因预期原因失败（缺少功能，不是拼写错误）
- [ ] 写了最小代码让每个测试通过
- [ ] 所有测试通过
- [ ] 输出干净（无错误、警告）

**无法检查所有框？你跳过了 TDD。重新开始。**

## 硬性约束
1. 必须先写测试，测试必须先失败
2. 不允许跳过红灯阶段
3. 重构后必须重新运行测试
4. 测试必须有实际断言，不允许空测试
5. **违反铁律 → 删除代码 → 重新开始**

## 调试集成

发现 bug？写失败测试重现它。遵循 TDD 循环。测试证明修复并防止回归。

**永远不要在没有测试的情况下修复 bug。**
```

---

## 3. code-review

**参考来源**：obra/superpowers requesting/receiving-code-review

```yaml
---
name: code-review
description: "Use when reviewing code changes after a Ticket is completed or when triggered with /review - performs technical evaluation focused on correctness, standards, performance, and security"
invoked_by: agent
---
```

### 评审维度

- 功能正确性
- 代码规范
- 性能考量
- 安全问题

### Prompt 模板

```markdown
# Code Review Skill

## 核心原则
**技术评估，非情感表演**：关注代码质量，而非个人风格。

## 评审流程

### Step 1: 获取变更
1. 读取 `workspace/logs/T-xxx.yaml` 获取变更文件
2. 使用 `git diff` 查看具体变更

### Step 2: 分维度评审

"""
## 🔍 代码评审 - T-{id}

### 1. 功能正确性
| 检查项 | 状态 | 说明 |
|--------|------|------|
| 实现是否符合需求 | ✅/⚠️/❌ | {说明} |
| 边界条件处理 | ✅/⚠️/❌ | {说明} |
| 异常处理 | ✅/⚠️/❌ | {说明} |

### 2. 代码规范
| 检查项 | 状态 | 说明 |
|--------|------|------|
| 命名规范 | ✅/⚠️/❌ | {说明} |
| 代码风格 | ✅/⚠️/❌ | {说明} |
| 注释完整性 | ✅/⚠️/❌ | {说明} |

### 3. 性能考量
| 检查项 | 状态 | 说明 |
|--------|------|------|
| 查询效率 | ✅/⚠️/❌ | {说明} |
| 内存使用 | ✅/⚠️/❌ | {说明} |

### 4. 安全问题
| 检查项 | 状态 | 说明 |
|--------|------|------|
| SQL 注入 | ✅/⚠️/❌ | {说明} |
| XSS 防护 | ✅/⚠️/❌ | {说明} |
| 权限校验 | ✅/⚠️/❌ | {说明} |
"""

### Step 3: 输出评审结果

"""
### 📋 评审结论

**整体评价**: {通过/需修改/不通过}

**必须修改**:
1. {issue_1} - {修改建议}

**建议优化**:
1. {suggestion_1}

**亮点**:
1. {highlight_1}
"""

### Step 4: 保存评审记录
保存到 `artifacts/reviews/T-xxx.md`

## 硬性约束
1. 必须覆盖四个评审维度
2. 每个问题必须有具体修改建议
3. 区分"必须修改"和"建议优化"
4. 评审结果必须保存
```

---

## 4. debugging

**参考来源**：obra/superpowers systematic-debugging

```yaml
---
name: debugging
description: "Use when encountering errors or unexpected behavior - enforces systematic root cause investigation before any fixes"
invoked_by: agent
---
```

### 铁律

```
NO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST
```

**如果你没有完成 Phase 1（根因调查），你不能提出修复。**

### 三次失败规则

> **如果连续 3 次修复都失败 → 停下来质疑架构**

这不是失败的假设，而是**错误的架构**。应该：
- 质疑模式本身是否合理
- 讨论是否应该重构架构
- **不要继续尝试修复**

**指示架构问题的模式**：
- 每个修复在不同地方揭示新的共享状态/耦合/问题
- 修复需要"大规模重构"来实现
- 每个修复在其他地方创建新症状

### 反合理化表格

| 借口 | 现实 |
|------|------|
| "问题很简单，不需要流程" | 简单问题也有根因。流程对简单 bug 也快。 |
| "紧急，没时间走流程" | 系统化调试比猜测-检查更快。 |
| "先试这个，然后调查" | 第一个修复定调。从一开始就做对。 |
| "一次修复多个，节省时间" | 无法隔离什么有效。导致新 bug。 |
| "参考太长，我会适配模式" | 部分理解保证 bug。完整读它。 |
| "我看到问题了，让我修" | 看到症状 ≠ 理解根因。 |
| "再试一次修复"（已经试了2次+） | 3次失败 = 架构问题。质疑模式，不是再修。 |

### 红旗 - 停止并遵循流程

如果你发现自己想：
- "快速修复现在，稍后调查"
- "只是尝试改变 X 看看是否有效"
- "添加多个变更，运行测试"
- "跳过测试，我会手动验证"
- "可能是 X，让我修那个"
- "我不完全理解但这可能有效"
- "这里是主要问题：[列出修复而不调查]"
- 在追踪数据流之前提出解决方案
- **"再试一次修复"（已经尝试 2+ 次）**
- **每个修复在不同地方揭示新问题**

**所有这些都意味着：停止。返回 Phase 1。**

### 四阶段调试流程

#### Phase 1: 根因调查（必须完成才能提出修复）

**在尝试任何修复之前**：

1. **仔细读错误消息**
   - 不要跳过错误或警告
   - 完整读堆栈跟踪
   - 注意行号、文件路径、错误代码

2. **一致复现**
   - 你能可靠触发它吗？
   - 确切的步骤是什么？
   - 如果不可复现 → 收集更多数据，不要猜测

3. **检查最近变更**
   - Git diff，最近提交
   - 新依赖、配置变更
   - 环境差异

4. **在多组件系统中收集证据**
   ```
   对于每个组件边界：
     - 记录进入组件的数据
     - 记录退出组件的数据
     - 验证环境/配置传播
   运行一次收集证据，显示在哪里中断
   ```

5. **追踪数据流**
   - 坏值从哪里来？
   - 什么用坏值调用了这个？
   - 继续向上追踪直到找到源头
   - **在源头修复，不在症状处**

#### Phase 2: 模式分析

1. **找工作的例子** - 在相同代码库中找到类似的工作代码
2. **对比参考** - 完整读参考实现，不要略读
3. **识别差异** - 工作的和坏的之间有什么不同
4. **理解依赖** - 需要什么其他组件、设置、配置

#### Phase 3: 假设测试

1. **形成单一假设** - 清楚说明："我认为 X 是根因，因为 Y"
2. **最小测试** - 做最小的可能变更来测试假设，一次一个变量
3. **在继续前验证** - 有效 → Phase 4；无效 → 新假设

#### Phase 4: 实现修复

1. **创建失败测试用例**（使用 TDD skill）
2. **实现单一修复** - 一次一个变更，没有"趁我在这里"的改进
3. **验证修复** - 测试通过，没有其他测试破坏
4. **如果修复无效**：
   - 计数：你尝试了多少修复？
   - 如果 < 3: 返回 Phase 1，用新信息重新分析
   - **如果 ≥ 3: 停止并质疑架构**

### Prompt 模板

```markdown
# Debugging Skill

## 铁律
**NO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST**

## 核心原则
**先找根因再修复**：禁止盲目尝试修复。

## 调试流程

### Phase 1: 根因调查
"""
## 🐛 错误信息

**错误类型**: {error_type}
**错误位置**: {file}:{line}

**错误信息**:
```
{完整错误堆栈}
```

**触发条件**: {如何复现}

**最近变更**: {git diff 或说明}

**数据流追踪**:
1. {数据从哪里来}
2. {经过哪些组件}
3. {在哪里出错}
"""

### Phase 2: 模式分析
"""
## 🔍 模式分析

**工作的例子**: {类似的工作代码}
**差异点**: {工作的和坏的之间的差异}
"""

### Phase 3: 假设验证
"""
## 🧪 假设验证

### 假设 1: {假设描述}
- **原因**: {为什么这样认为}
- **验证方法**: {如何验证}
- **验证结果**: {结果}
- **结论**: ✅ 确认 / ❌ 排除

### 假设 2: {假设描述}
...

### 根因确认
经分析，根因是：**{根因描述}**

**证据**:
1. {证据1}
2. {证据2}
"""

### Phase 4: 实现修复
"""
## 🔧 修复方案

**根因**: {根因描述}
**修复尝试次数**: {N}/3

**失败测试**（先写）:
```java
@Test
public void test_bugReproduction() {
    // 复现 bug 的测试
}
```

**修复方法**:
```java
// 修复前
{old_code}

// 修复后
{new_code}
```

**影响范围**: {affected_files}
"""

### 修复验证
"""
## ✅ 修复验证

**测试命令**: `{command}`

**测试结果**:
```
{test_output}
```

**结论**: 修复成功 ✅ / 修复失败，返回 Phase 1
"""

## 三次失败规则
如果连续 3 次修复失败：
"""
## ⚠️ 架构问题

**修复尝试**: 3/3 失败

**模式**:
- 修复 1: {问题}
- 修复 2: {问题}
- 修复 3: {问题}

**分析**: 每个修复揭示新问题，表明架构问题

**建议**: 停止修复，讨论架构重构
"""

## 硬性约束
1. 必须先分析根因，再提出修复
2. 根因分析必须有验证过程
3. 修复后必须验证
4. 禁止"试试看"的盲目修复
5. **连续 3 次修复失败 → 停止并质疑架构**
```

---

## 相关文档

- [00_概览](00_概览.md) - 返回概览
- [11_Skills_工作流](11_Skills_工作流.md) - 工作流 Skills
- [13_Skills_自动化](13_Skills_自动化.md) - 自动化 Skills
