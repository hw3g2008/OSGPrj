# 低智商模型执行指南

> **重要**：本文档为便宜/低智商模型提供精确到字符级别的执行指令。如果使用 Claude Opus/Sonnet 等高智商模型，可参考但不必严格遵循。

---

## 0. 核心原则

**低智商模型执行必须遵循：**

1. **零推断** - 不能假设任何事情，所有信息必须从文件中读取
2. **精确匹配** - 所有路径、字段名、格式必须完全一致
3. **量化判断** - 所有判断条件必须有明确的数字标准
4. **完整示例** - 每个操作都有输入→输出的完整示例
5. **显式错误处理** - 每个步骤都有"如果失败怎么办"
6. **校验维度矩阵** - 校验必须按维度逐项检查，不能只检查"想到的"

### 0.1 校验维度矩阵（必须逐项检查）

```yaml
# 每次校验都必须检查以下所有维度：

结构层:  # "骨架是否正确"
  - 数字一致: "Skills=16、Agents=6 等数字是否到处一致"
  - 导航一致: "目录表格、相关文档链接是否匹配"
  - 目录一致: "文件结构、路径引用是否正确"
  - 链接完整: "所有内部链接是否都能找到目标文件"

格式层:  # "格式是否统一"
  - ID 格式: "REQ-xxx、S-xxx、T-xxx 等格式是否正确"
  - 时间格式: "是否都是 ISO 8601 UTC 格式"
  - 路径格式: "是否使用相对路径、是否在 allowed_paths 内"
  - 代码格式: "代码块是否闭合、是否有语言标识"

语义层:  # "内容是否一致" ⚠️ 最容易遗漏！
  - 技术版本: "从 config.yaml 读取，检查代码是否匹配配置（不要硬编码版本号）"
  - 配置值: "从 config.yaml 读取，检查引用是否一致"
  - 业务术语: "角色名、模块名、状态名是否统一"
  - 示例数据: "示例中的 ID、名称是否合理"

逻辑层:  # "逻辑是否完整"
  - 流程完整: "所有分支是否都有处理"
  - 依赖正确: "A 依赖 B，B 是否先定义"
  - 条件互斥: "if/else 条件是否不重叠"
  - 边界处理: "空值、极端值、错误是否都有处理"
```

**执行规则**：
1. **逐项检查** - 不能跳过任何一个维度
2. **有修改就重检** - 修改任何内容后，重新检查所有维度
3. **无轮次限制** - 直到所有维度都无修改才结束

---

## 0.5 读取 config.yaml（所有命令的前置步骤）

> ⚠️ **重要**：在执行任何命令之前，必须先读取 config.yaml 获取项目配置。

### 0.5.1 读取步骤

```python
# 步骤 1：检查文件是否存在
config_path = ".claude/project/config.yaml"
IF NOT 文件存在(config_path):
    输出错误: "config.yaml 不存在，请先执行 /init-project"
    停止执行
    
# 步骤 2：读取并解析 YAML
config = 读取YAML文件(config_path)

# 步骤 3：验证必填字段
必填字段 = ["name", "type", "tech_stack", "commands", "paths"]
FOR 字段 IN 必填字段:
    IF 字段 NOT IN config:
        输出错误: f"config.yaml 缺少必填字段: {字段}"
        停止执行
```

### 0.5.2 从 config 获取值的方式

```python
# 获取技术栈信息
后端语言 = config["tech_stack"]["backend"]["language"]      # 如 "java"
后端运行时 = config["tech_stack"]["backend"]["runtime"]    # 如 "Java 17"
前端框架 = config["tech_stack"]["frontend"]["framework"]   # 如 "vue"

# 获取命令
测试命令 = config["commands"]["test"]                      # 如 "mvn test"
构建命令 = config["commands"]["build"]                     # 如 "mvn package"
前端开发命令 = config["commands"]["frontend"]["dev"]       # 如 "pnpm dev"

# 获取路径
后端源码目录 = config["paths"]["backend"]["source"]        # 如 "ruoyi-*/src/main/java/"
前端组件目录 = config["paths"]["frontend"]["components"]   # 如 "src/components/"
```

### 0.5.3 使用示例

**场景**：执行 tdd skill 时需要运行测试

```python
# 错误方式 ❌ - 硬编码命令
运行命令("mvn test")

# 正确方式 ✅ - 从 config 读取
config = 读取YAML文件(".claude/project/config.yaml")
测试命令 = config["commands"]["test"]  # 可能是 "mvn test" 或 "pytest" 或 "go test"
运行命令(测试命令)
```

**场景**：deliver-ticket 需要知道代码放哪里

```python
# 错误方式 ❌ - 硬编码路径
创建文件("ruoyi-admin/src/main/java/.../Controller.java")

# 正确方式 ✅ - 从 config 读取
config = 读取YAML文件(".claude/project/config.yaml")
控制器目录 = config["paths"]["backend"]["controllers"]  # 从配置获取
创建文件(f"{控制器目录}/XxxController.java")
```

---

## 1. 命令解析规则

### 1.1 如何识别用户命令

**判断逻辑**：

```
IF 用户输入以 "/" 开头:
    提取命令名 = 第一个空格前的部分（去掉 "/"）
    提取参数 = 空格后的所有部分
    
    命令名匹配规则（精确匹配，区分大小写）:
    - "brainstorm" → 执行 brainstorm 命令
    - "split" → 检查下一个词：
        - "story" → 执行 story-splitter
        - "ticket" → 执行 ticket-splitter，参数为 S-xxx
    - "next" → 执行 next 命令
    - "status" → 执行 status 命令
    - "approve" → 执行 approve 命令
    - "checkpoint" 或 "save" → 执行 checkpoint 命令
    - "restore" → 执行 restore 命令
    - "rollback" → 执行 rollback 命令
    
ELSE:
    这不是命令，正常对话
```

**示例**：

| 用户输入 | 命令名 | 参数 |
|---------|--------|------|
| `/brainstorm 学生登录` | brainstorm | 学生登录 |
| `/split story` | split story | (无) |
| `/split ticket S-001` | split ticket | S-001 |
| `/next` | next | (无) |
| `/status --detail` | status | --detail |
| `/approve stories` | approve | stories |

---

## 2. /brainstorm 命令精确执行步骤

### 2.1 Step 1：解析输入参数

**输入**：`/brainstorm [模块名]`

**参数提取规则**：
- 如果 `/brainstorm` 后有内容 → 模块名 = 空格后的所有文字
- 如果 `/brainstorm` 后无内容 → 报错：`请指定模块名，如 /brainstorm 学生登录`

**模块名转关键词规则**（逐字符处理）：

```python
def 模块名转关键词(模块名: str) -> list[str]:
    """
    将中文模块名转换为搜索关键词列表
    
    示例：
    - "学生登录" → ["学生", "登录", "student", "login", "auth"]
    - "用户管理" → ["用户", "管理", "user", "manage"]
    - "课程排期" → ["课程", "排期", "course", "schedule"]
    """
    关键词 = []
    
    # 1. 添加原始模块名
    关键词.append(模块名)
    
    # 2. 拆分中文词（每2个字符一组）
    for i in range(0, len(模块名), 2):
        if i + 2 <= len(模块名):
            关键词.append(模块名[i:i+2])
    
    # 3. 添加英文翻译（固定映射表）
    翻译表 = {
        "学生": ["student"],
        "登录": ["login", "auth", "signin"],
        "用户": ["user"],
        "管理": ["manage", "management"],
        "课程": ["course"],
        "排期": ["schedule"],
        "导师": ["mentor", "teacher"],
        "班主任": ["lead-mentor", "class-teacher"],
        "助教": ["assistant"],
        "合同": ["contract"],
        "结算": ["settlement"],
        "报销": ["reimbursement"],
        "面试": ["interview"],
        "简历": ["resume"],
        "文件": ["file"],
        "题库": ["question", "quiz"],
    }
    
    for 中文词 in 关键词[1:]:  # 跳过原始模块名
        if 中文词 in 翻译表:
            关键词.extend(翻译表[中文词])
    
    return 关键词
```

**执行示例**：

```
输入: /brainstorm 学生登录
模块名 = "学生登录"
关键词 = ["学生登录", "学生", "登录", "student", "login", "auth", "signin"]
```

### 2.2 Step 2：读取基础文档（精确步骤）

**必须按以下顺序读取文件**：

```python
def 读取基础文档(关键词: list[str]) -> dict:
    """
    按顺序读取文档，搜索关键词
    返回：找到的相关内容
    """
    结果 = {
        "api": [],
        "database": [],
        "routes": [],
        "requirements": [],
        "types": []
    }
    
    # 1. 读取 API 规范
    api文件 = "osg-spec-docs/docs/06-api/openapi.yaml"
    if 文件存在(api文件):
        内容 = 读取文件(api文件)
        for 关键词 in 关键词:
            匹配行 = 搜索包含关键词的行(内容, 关键词)
            if 匹配行:
                结果["api"].extend(匹配行)
    else:
        输出警告(f"⚠️ 文件不存在: {api文件}")
    
    # 2. 读取数据库设计
    db文件 = "osg-spec-docs/docs/07-database/DB-DDL-001_table-definitions.md"
    if 文件存在(db文件):
        内容 = 读取文件(db文件)
        for 关键词 in 关键词:
            匹配行 = 搜索包含关键词的行(内容, 关键词)
            if 匹配行:
                结果["database"].extend(匹配行)
    else:
        输出警告(f"⚠️ 文件不存在: {db文件}")
    
    # 3. 读取路由规格（使用通配符）
    routes目录 = "osg-spec-docs/docs/03-design/routes/"
    if 目录存在(routes目录):
        for 文件名 in 列出目录文件(routes目录, "*.ts"):
            内容 = 读取文件(routes目录 + 文件名)
            for 关键词 in 关键词:
                if 关键词.lower() in 内容.lower():
                    结果["routes"].append({
                        "file": 文件名,
                        "content": 提取相关段落(内容, 关键词)
                    })
    else:
        输出警告(f"⚠️ 目录不存在: {routes目录}")
    
    # 4. 读取功能需求
    req目录 = "osg-spec-docs/docs/02-requirements/functional/"
    if 目录存在(req目录):
        for 文件名 in 列出目录文件(req目录, "REQ-FUN-*.md"):
            内容 = 读取文件(req目录 + 文件名)
            for 关键词 in 关键词:
                if 关键词.lower() in 内容.lower():
                    结果["requirements"].append({
                        "file": 文件名,
                        "content": 提取相关段落(内容, 关键词)
                    })
    
    # 5. 读取类型定义
    types文件 = "osg-spec-docs/docs/07-database/types.ts"
    if 文件存在(types文件):
        内容 = 读取文件(types文件)
        for 关键词 in 关键词:
            匹配行 = 搜索包含关键词的行(内容, 关键词)
            if 匹配行:
                结果["types"].extend(匹配行)
    
    return 结果
```

**输出格式**（必须严格遵循）：

```markdown
## 📖 Step 1: 读取基础文档

正在读取以下文档：

### API 规范
- 文件: osg-spec-docs/docs/06-api/openapi.yaml
- 状态: ✅ 已读取
- 找到相关内容: 是/否
- 相关内容摘要:
  ```yaml
  # 找到的 API 定义
  /api/student/auth/login:
    post:
      summary: 学生登录
      ...
  ```

### 数据库设计
- 文件: osg-spec-docs/docs/07-database/DB-DDL-001_table-definitions.md
- 状态: ✅ 已读取 / ⚠️ 文件不存在
- 找到相关内容: 是/否
- 相关内容摘要:
  ```sql
  -- 找到的表定义
  CREATE TABLE osg_student (
    ...
  );
  ```

### 路由规格
- 目录: osg-spec-docs/docs/03-design/routes/
- 状态: ✅ 已读取
- 匹配文件: student-routes.ts
- 相关内容摘要:
  ```typescript
  // 找到的路由
  ...
  ```

### 功能需求
- 目录: osg-spec-docs/docs/02-requirements/functional/
- 状态: ✅ 已读取
- 匹配文件: REQ-FUN-001-auth.md
- 相关内容摘要:
  ```
  ...
  ```

### 类型定义
- 文件: osg-spec-docs/docs/07-database/types.ts
- 状态: ✅ 已读取
- 相关内容摘要:
  ```typescript
  interface StudentLoginRequest {
    ...
  }
  ```

---

**文档读取统计**:
- 总文件数: 5
- 成功读取: 5
- 失败: 0
- 找到相关内容的文件: 4
```

### 2.3 Step 3：生成初版需求文档（精确模板）

**必须按以下模板生成**：

```markdown
# REQ-{序号}: {模块名}

## 需求信息
- **需求 ID**: REQ-{序号}
- **模块名**: {模块名}
- **创建时间**: {当前日期时间，格式：YYYY-MM-DDTHH:MM:SSZ}
- **状态**: draft

## 需求概述

### 功能描述
{一段话描述功能，必须包含：做什么、给谁用、什么场景}

### 业务价值
{为什么需要这个功能，必须包含：解决什么问题、带来什么价值}

## 来源文档
| 文档类型 | 文件路径 | 行号/位置 |
|---------|---------|----------|
| API 规范 | osg-spec-docs/docs/06-api/openapi.yaml | 第 {N} 行 |
| 数据库设计 | osg-spec-docs/docs/07-database/... | 第 {N} 行 |
| 功能需求 | osg-spec-docs/docs/02-requirements/functional/... | 全文 |

## 涉及文件（精确路径）

### 前端文件
| 文件路径 | 操作 | 说明 |
|---------|------|------|
| osg-frontend/packages/{端}/src/views/{页面}/index.vue | 修改/新增 | {具体说明} |
| osg-frontend/packages/shared/src/api/{模块}.ts | 修改/新增 | {具体说明} |

### 后端文件
| 文件路径 | 操作 | 说明 |
|---------|------|------|
| ruoyi-admin/src/main/java/com/osg/controller/{Controller}.java | 修改/新增 | {具体说明} |
| ruoyi-system/src/main/java/com/osg/service/I{Service}.java | 修改/新增 | {具体说明} |
| ruoyi-system/src/main/java/com/osg/service/impl/{Service}Impl.java | 修改/新增 | {具体说明} |
| ruoyi-system/src/main/java/com/osg/mapper/{Mapper}.java | 修改/新增 | {具体说明} |

## 实现细节

### 需要修改的方法/函数

#### 前端
| 文件 | 方法/函数 | 参数 | 返回值 | 修改内容 |
|------|---------|------|--------|---------|
| {文件路径} | {方法名}({参数}) | {参数类型} | {返回类型} | {具体修改内容} |

#### 后端
| 文件 | 方法/函数 | 参数 | 返回值 | 修改内容 |
|------|---------|------|--------|---------|
| {文件路径} | {方法名}({参数}) | {参数类型} | {返回类型} | {具体修改内容} |

### 代码片段示例

#### 前端示例
```typescript
// 文件: osg-frontend/packages/{端}/src/api/{模块}.ts
// 新增/修改的函数

export async function {函数名}({参数}: {参数类型}): Promise<{返回类型}> {
  return request({
    url: '/api/{路径}',
    method: 'post',
    data: {参数}
  })
}
```

#### 后端示例
```java
// 文件: ruoyi-admin/src/main/java/com/osg/controller/{Controller}.java
// 新增/修改的方法

@PostMapping("/{路径}")
public AjaxResult {方法名}(@RequestBody {请求类型} request) {
    // 具体实现
    return AjaxResult.success({服务}.{方法}(request));
}
```

## 测试用例
| 用例名 | 类型 | 输入 | 预期输出 | 说明 |
|-------|------|------|---------|------|
| test{功能}_success | 正向 | {具体输入} | {具体输出} | 正常场景 |
| test{功能}_invalidInput | 反向 | {具体输入} | {错误信息} | 异常场景 |
| test{功能}_boundary | 边界 | {边界值} | {预期结果} | 边界情况 |

## 验收标准
- [ ] {可验证的标准1，必须是布尔型：是/否}
- [ ] {可验证的标准2}
- [ ] {可验证的标准3}

## 影响分析

### 影响的模块
| 模块 | 影响类型 | 影响说明 |
|------|---------|---------|
| {模块名} | 直接/间接 | {具体影响} |

### 依赖关系
| 依赖项 | 依赖类型 | 说明 |
|-------|---------|------|
| {依赖} | 功能/数据/服务 | {具体说明} |

## 异常处理
| 异常场景 | 触发条件 | 处理方式 | 用户提示 |
|---------|---------|---------|---------|
| 空输入 | {参数} 为空 | 返回 400 | "请输入{字段}" |
| 网络错误 | 请求超时 | 重试3次后提示 | "网络错误，请稍后重试" |
| 权限不足 | 未登录/无权限 | 返回 401/403 | "请先登录" / "无权限访问" |
| 数据不存在 | ID 对应数据不存在 | 返回 404 | "{对象}不存在" |
| 服务器错误 | 未知异常 | 返回 500 + 记录日志 | "系统错误，请联系管理员" |

## 安全考虑
- [ ] SQL 注入防护：使用参数化查询
- [ ] XSS 防护：前端输出转义
- [ ] CSRF 防护：Token 校验
- [ ] 权限校验：@PreAuthorize 注解
- [ ] 敏感数据：密码加密、日志脱敏

## Out of Scope（不在本次范围）
- {不在范围的功能1}
- {不在范围的功能2}
```

### 2.4 Step 4：正向校验（量化判断标准）

**对每个检查项，必须执行以下判断逻辑**：

#### 检查项 1：细致度

```python
def 检查细致度(需求文档: str) -> tuple[bool, list[str]]:
    """
    检查需求文档的细致度
    返回：(是否通过, 问题列表)
    """
    问题列表 = []
    
    # 规则 1：检查是否有模糊表述
    模糊词列表 = ["相关", "等", "...", "其他", "类似", "比如", "例如"]
    for 模糊词 in 模糊词列表:
        if 模糊词 in 需求文档:
            问题列表.append(f"发现模糊表述：'{模糊词}'，需要替换为具体内容")
    
    # 规则 2：检查文件路径是否完整
    # 完整路径必须以 "osg-frontend/" 或 "ruoyi-" 开头
    文件路径正则 = r"(osg-frontend/|ruoyi-)[^\s]+\.(vue|ts|java|xml)"
    所有路径 = 正则提取(需求文档, 文件路径正则)
    
    # 检查"涉及文件"表格
    if "涉及文件" in 需求文档:
        表格行 = 提取表格行(需求文档, "涉及文件")
        for 行 in 表格行:
            if not 正则匹配(行, 文件路径正则):
                问题列表.append(f"文件路径不完整：{行}")
    
    # 规则 3：检查方法是否有参数和返回值
    if "需要修改的方法" in 需求文档:
        表格行 = 提取表格行(需求文档, "需要修改的方法")
        for 行 in 表格行:
            if "参数" not in 行 or "返回值" not in 行:
                问题列表.append(f"方法缺少参数或返回值说明：{行}")
    
    # 规则 4：检查是否有代码片段
    if "```" not in 需求文档:
        问题列表.append("缺少代码片段示例")
    
    return (len(问题列表) == 0, 问题列表)
```

**判断结果输出格式**：

```markdown
### 检查项 1：细致度

**判断逻辑**：
1. 检查模糊表述 → {发现/未发现} {N} 个
2. 检查文件路径完整性 → {N}/{M} 个路径完整
3. 检查方法说明完整性 → {N}/{M} 个方法有完整说明
4. 检查代码片段 → {有/无}

**结论**：{✅ 通过 / ⚠️ 不通过}

**问题列表**（如不通过）：
1. {问题1}
2. {问题2}
```

#### 检查项 2-5 类似逻辑

（其他 4 个检查项的量化判断标准，结构相同）

### 2.5 Step 5：反向校验（量化判断标准）

#### 检查项 1：用户视角

```python
def 检查用户视角(需求文档: str) -> tuple[bool, list[str]]:
    """
    检查是否覆盖用户问题场景
    返回：(是否通过, 问题列表)
    """
    问题列表 = []
    
    # 规则：必须列出至少 3 个用户问题场景
    if "异常处理" in 需求文档:
        异常场景 = 提取表格行(需求文档, "异常处理")
        场景数 = len(异常场景)
        
        if 场景数 < 3:
            问题列表.append(f"用户问题场景不足：当前 {场景数} 个，需要至少 3 个")
            问题列表.append("建议补充：空输入、网络错误、权限不足等场景")
    else:
        问题列表.append("缺少'异常处理'章节")
    
    return (len(问题列表) == 0, 问题列表)
```

### 2.6 Step 6：保存需求文档（精确操作）

**文件保存规则**：

```python
def 保存需求文档(需求文档: str, 模块名: str) -> str:
    """
    保存需求文档到指定路径
    返回：保存的文件路径
    """
    # 1. 将中文模块名转换为 kebab-case
    目录名 = 中文转kebab_case(模块名)
    # 示例："学生登录" → "student-login"
    
    # 2. 确定序号
    基础目录 = "osg-spec-docs/docs/12-implementation/"
    现有文件 = 列出目录文件(基础目录, "REQ-*.md")
    序号 = len(现有文件) + 1
    序号字符串 = str(序号).zfill(3)  # 补零到 3 位
    
    # 3. 创建目录
    目标目录 = f"{基础目录}{目录名}/"
    创建目录(目标目录)
    
    # 4. 保存文件
    文件名 = f"REQ-{序号字符串}-{目录名}.md"
    文件路径 = 目标目录 + 文件名
    写入文件(文件路径, 需求文档)
    
    return 文件路径

def 中文转kebab_case(中文: str) -> str:
    """
    将中文转换为 kebab-case
    
    固定映射表：
    """
    映射表 = {
        "学生登录": "student-login",
        "用户管理": "user-management",
        "课程排期": "course-scheduling",
        "导师管理": "mentor-management",
        "班主任管理": "lead-mentor-management",
        "助教管理": "assistant-management",
        "合同管理": "contract-management",
        "结算管理": "settlement-management",
        "报销管理": "reimbursement-management",
        "面试管理": "interview-management",
        "简历管理": "resume-management",
        "文件管理": "file-management",
        "题库管理": "question-management",
    }
    
    if 中文 in 映射表:
        return 映射表[中文]
    else:
        # 如果不在映射表中，使用拼音转换
        # 格式：每个词的拼音首字母小写，用 - 连接
        return 中文.lower().replace(" ", "-")
```

---

## 3. /next 命令精确执行步骤

### 3.1 Step 1：读取 STATE.yaml

**精确读取路径**：`osg-spec-docs/tasks/STATE.yaml`

**如果文件不存在**：
```markdown
## ❌ 错误：STATE.yaml 不存在

检测到项目未初始化，请先执行：
```
/init-project
```
```

**必须读取的字段**：

```yaml
# 从 STATE.yaml 提取以下字段
current:
  story: "S-001"      # 当前 Story ID，如果为 null 则需要查找
  ticket: "T-003"     # 当前 Ticket ID，如果为 null 则需要查找
  
stories:
  S-001:
    status: "in_progress"
    tickets:
      - id: "T-001"
        status: "completed"
      - id: "T-002"
        status: "completed"
      - id: "T-003"
        status: "pending"      # ← 找到第一个 pending 的
```

### 3.2 Step 2：找到下一个待执行的 Ticket

```python
def 找下一个Ticket() -> str | None:
    """
    按顺序找到下一个待执行的 Ticket
    返回：Ticket ID 或 None
    """
    state = 读取yaml("osg-spec-docs/tasks/STATE.yaml")
    
    # 1. 如果 current.ticket 有值且状态为 pending，直接返回
    if state["current"]["ticket"]:
        ticket_id = state["current"]["ticket"]
        ticket = 读取yaml(f"osg-spec-docs/tasks/tickets/{ticket_id}.yaml")
        if ticket["status"] == "pending":
            return ticket_id
    
    # 2. 否则，遍历所有 Story 找第一个 pending 的 Ticket
    for story_id, story_data in state["stories"].items():
        if story_data["status"] in ["pending", "in_progress"]:
            for ticket_info in story_data["tickets"]:
                if ticket_info["status"] == "pending":
                    return ticket_info["id"]
    
    # 3. 没有找到待执行的 Ticket
    return None
```

**如果没有找到 Ticket**：
```markdown
## ✅ 所有任务已完成

当前没有待执行的 Ticket。

**状态**：
- 所有 Stories: 已完成
- 所有 Tickets: 已完成

**下一步**：
- 如有新需求，运行 `/brainstorm` 开始新任务
- 查看状态：`/status --detail`
```

### 3.3 Step 3：读取 Ticket 定义

**精确读取路径**：`osg-spec-docs/tasks/tickets/{ticket_id}.yaml`

**必须读取的字段**：

```yaml
id: "T-003"
story_id: "S-001"
title: "用户编辑 API"
description: "实现用户信息编辑接口"
type: "backend"                # ← 用于确定 Agent
agent: "backend-java"          # ← 明确指定的 Agent

allowed_paths:
  modify:
    - "ruoyi-admin/src/main/java/**/controller/SysUserController.java"
  create:
    - "ruoyi-admin/src/test/java/**/SysUserControllerTest.java"
  read:
    - "ruoyi-admin/src/main/java/**/controller/SysDeptController.java"

tdd:
  test_file: "ruoyi-admin/src/test/java/.../SysUserControllerTest.java"
  test_cases:
    - name: "testEditUser_success"
      description: "正常修改用户信息"

acceptance:
  - type: "command"
    run: "mvn test -Dtest=SysUserControllerTest"
    expect: "BUILD SUCCESS"
```

### 3.4 Step 4：确定并加载 Agent

**Agent 确定规则**：

```python
def 确定Agent(ticket: dict) -> str:
    """
    根据 Ticket 确定要使用的 Agent
    """
    # 1. 如果 Ticket 明确指定了 agent，使用指定的
    if "agent" in ticket and ticket["agent"]:
        return ticket["agent"]
    
    # 2. 否则根据 type 映射
    type_to_agent = {
        "backend": "backend-java",
        "frontend": "frontend-vue",
        "database": "dba-mysql",
        "fullstack": "backend-java"  # 默认后端
    }
    return type_to_agent.get(ticket["type"], "backend-java")
```

**Agent 加载步骤**：

```python
def 加载Agent(agent_name: str) -> dict:
    """
    加载 Agent 配置
    """
    # 1. 读取 Agent 文件
    agent_path = f".claude/project/agents/{agent_name}.md"
    if not 文件存在(agent_path):
        agent_path = f".claude/agents/{agent_name}.md"
    
    agent_content = 读取文件(agent_path)
    
    # 2. 解析 YAML frontmatter
    frontmatter = 解析yaml头(agent_content)
    # frontmatter 示例:
    # {
    #   "name": "backend-java",
    #   "skills": ["deliver-ticket", "tdd", "checkpoint-manager"],
    #   "rules": "java"
    # }
    
    # 3. 加载关联的 Skills
    skills = []
    for skill_name in frontmatter["skills"]:
        skill_path = f".claude/skills/{skill_name}/SKILL.md"
        if 文件存在(skill_path):
            skills.append(读取文件(skill_path))
    
    return {
        "agent": agent_content,
        "skills": skills
    }
```

**输出格式**：

```markdown
## 🔄 任务分派

**下一个 Ticket**: T-003 - 用户编辑 API
**类型**: backend
**分派给**: backend-java Agent

---

## 📋 [backend-java Agent] 加载配置

**Agent 文件**: .claude/project/agents/backend-java.md
**加载的 Skills**:
- deliver-ticket ✅
- tdd ✅
- checkpoint-manager ✅

**代码规范**: java.md

---

## 📋 任务理解

**Ticket**: T-003 - 用户编辑 API

**目标**: 
实现用户信息编辑接口，允许管理员修改用户基本信息。

**允许修改的文件**:
- ruoyi-admin/src/main/java/**/controller/SysUserController.java

**可以新建的文件**:
- ruoyi-admin/src/test/java/**/SysUserControllerTest.java

**参考文件**:
- ruoyi-admin/src/main/java/**/controller/SysDeptController.java

**验收标准**:
1. 命令 `mvn test -Dtest=SysUserControllerTest` 输出包含 "BUILD SUCCESS"

✅ 理解确认，开始执行。
```

### 3.5 Step 5-9：执行 deliver-ticket Skill

（详细步骤见 deliver-ticket Skill 的精确执行指南）

---

## 4. 状态文件操作精确示例

### 4.1 更新 STATE.yaml

**场景：Ticket T-003 开始执行**

**读取前**：
```yaml
phase: "implement"
current:
  story: "S-001"
  ticket: null
  agent: null
stories:
  S-001:
    status: "in_progress"
    progress: "2/5"
    tickets:
      - id: "T-003"
        status: "pending"
```

**更新操作**：
```python
state["current"]["ticket"] = "T-003"
state["current"]["agent"] = "backend-java"
state["stories"]["S-001"]["tickets"][2]["status"] = "in_progress"
state["last_updated"] = 当前时间()
写入yaml("osg-spec-docs/tasks/STATE.yaml", state)
```

**更新后**：
```yaml
phase: "implement"
current:
  story: "S-001"
  ticket: "T-003"
  agent: "backend-java"
last_updated: "2026-02-03T10:30:00Z"
stories:
  S-001:
    status: "in_progress"
    progress: "2/5"
    tickets:
      - id: "T-003"
        status: "in_progress"
```

### 4.2 创建 Ticket 日志

**场景：Ticket T-003 执行完成**

**文件路径**：`workspace/logs/T-003.yaml`

**完整内容**：
```yaml
ticket_id: "T-003"
story_id: "S-001"
agent: "backend-java"
session_id: "2026-02-03-001"

started_at: "2026-02-03T10:30:00Z"
finished_at: "2026-02-03T10:35:00Z"
duration_seconds: 300

status: "success"
exit_reason: "all_acceptance_passed"

steps:
  - step: 1
    action: "read_ticket"
    status: "success"
    timestamp: "2026-02-03T10:30:00Z"
    duration_ms: 100
    details: "读取 osg-spec-docs/tasks/tickets/T-003.yaml"
    
  - step: 2
    action: "read_reference"
    status: "success"
    timestamp: "2026-02-03T10:30:01Z"
    duration_ms: 500
    files_read:
      - "ruoyi-admin/src/main/java/.../SysDeptController.java"
    
  - step: 3
    action: "write_test"
    status: "success"
    timestamp: "2026-02-03T10:31:00Z"
    duration_ms: 30000
    files_created:
      - "ruoyi-admin/src/test/java/.../SysUserControllerTest.java"
    
  - step: 4
    action: "run_test_red"
    status: "success"
    timestamp: "2026-02-03T10:31:30Z"
    duration_ms: 5000
    command: "mvn test -Dtest=SysUserControllerTest"
    output: |
      [INFO] Tests run: 1, Failures: 1
      [INFO] BUILD FAILURE
    attempt: 1
    
  - step: 5
    action: "implement"
    status: "success"
    timestamp: "2026-02-03T10:32:00Z"
    duration_ms: 60000
    files_modified:
      - "ruoyi-admin/src/main/java/.../SysUserController.java"
    
  - step: 6
    action: "run_test_green"
    status: "success"
    timestamp: "2026-02-03T10:33:00Z"
    duration_ms: 5000
    command: "mvn test -Dtest=SysUserControllerTest"
    output: |
      [INFO] Tests run: 1, Failures: 0
      [INFO] BUILD SUCCESS
    attempt: 1
    
  - step: 7
    action: "run_lint"
    status: "success"
    timestamp: "2026-02-03T10:33:30Z"
    duration_ms: 3000
    command: "mvn checkstyle:check"
    output: |
      [INFO] BUILD SUCCESS
    
  - step: 8
    action: "self_review"
    status: "success"
    timestamp: "2026-02-03T10:34:00Z"
    duration_ms: 5000
    details: "自我审查通过：完整性 ✅, 质量 ✅, 测试 ✅"
    
  - step: 9
    action: "create_checkpoint"
    status: "success"
    timestamp: "2026-02-03T10:34:30Z"
    duration_ms: 2000
    checkpoint_id: "CP-20260203-103430"

evidence:
  - type: "test_output"
    command: "mvn test -Dtest=SysUserControllerTest"
    output: |
      [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
      [INFO] BUILD SUCCESS
    timestamp: "2026-02-03T10:33:00Z"

files_changed:
  created:
    - "ruoyi-admin/src/test/java/.../SysUserControllerTest.java"
  modified:
    - "ruoyi-admin/src/main/java/.../SysUserController.java"
  deleted: []

checkpoint:
  id: "CP-20260203-103430"
  git_commit: "abc1234"
  can_rollback: true
```

---

## 5. 错误处理精确步骤

### 5.1 文件不存在

**场景**：读取 `osg-spec-docs/tasks/STATE.yaml` 时文件不存在

**判断逻辑**：
```python
if not 文件存在("osg-spec-docs/tasks/STATE.yaml"):
    # 执行错误处理
```

**输出格式**：
```markdown
## ❌ 错误：文件不存在

**文件**: osg-spec-docs/tasks/STATE.yaml
**原因**: 项目未初始化

**解决方案**:
请先执行以下命令初始化项目：
```
/init-project
```

如果已经初始化，请检查：
1. 当前目录是否正确（应在项目根目录）
2. osg-spec-docs/tasks/ 目录是否存在
```

### 5.2 Ticket 状态不正确

**场景**：尝试执行已完成的 Ticket

**判断逻辑**：
```python
ticket = 读取yaml(f"osg-spec-docs/tasks/tickets/{ticket_id}.yaml")
if ticket["status"] != "pending":
    # 执行错误处理
```

**输出格式**：
```markdown
## ⚠️ 警告：Ticket 状态不正确

**Ticket**: T-003
**当前状态**: completed
**预期状态**: pending

**可能原因**:
1. 该 Ticket 已经执行完成
2. STATE.yaml 与 Ticket 文件状态不一致

**解决方案**:
- 查看下一个 Ticket: `/next`
- 重新执行该 Ticket: `/retry T-003`
- 查看状态: `/status --detail`
```

### 5.3 测试失败重试

**场景**：TDD 红灯阶段测试命令执行失败（非预期失败）

**判断逻辑**：
```python
def 执行测试(命令: str, 预期结果: str, 当前阶段: str) -> tuple[bool, str]:
    """
    执行测试命令
    返回：(是否符合预期, 实际输出)
    """
    输出 = 执行命令(命令)
    
    if 当前阶段 == "红灯":
        # 红灯阶段：测试应该失败
        if "FAILURE" in 输出 or "Failures: " in 输出:
            return (True, 输出)  # 符合预期
        elif "SUCCESS" in 输出:
            return (False, "测试立即通过，可能测试代码有问题")
        else:
            return (False, f"测试执行出错：{输出}")
    
    elif 当前阶段 == "绿灯":
        # 绿灯阶段：测试应该通过
        if "SUCCESS" in 输出:
            return (True, 输出)
        else:
            return (False, 输出)  # 需要修复
```

**失败重试逻辑**：
```python
MAX_RETRIES = 3
重试次数 = 0

while 重试次数 < MAX_RETRIES:
    (成功, 输出) = 执行测试(命令, 预期, 阶段)
    
    if 成功:
        break
    
    重试次数 += 1
    if 重试次数 < MAX_RETRIES:
        输出(f"测试失败（第 {重试次数} 次），分析问题并修复...")
        # 调用 debugging skill 分析
        问题 = 分析测试失败(输出)
        修复代码(问题)
    else:
        输出(f"测试失败达到最大重试次数 ({MAX_RETRIES})，停止执行")
        标记Ticket状态("failed")
        break
```

**输出格式**：
```markdown
## ⚠️ 测试失败 - 重试 {N}/{MAX_RETRIES}

**命令**: mvn test -Dtest=SysUserControllerTest
**预期**: BUILD SUCCESS
**实际**:
```
[INFO] Tests run: 1, Failures: 1
FAILED: testEditUser_success
Expected: 200
Actual: 500
```

**问题分析**:
- 错误类型: 断言失败
- 根本原因: 方法返回 500，可能是空指针异常

**修复尝试**:
1. 检查 editUser 方法的参数校验
2. 添加空值处理

**修复后重新测试...**
```

---

## 6. 完整执行示例

### 6.1 /brainstorm 完整执行

（此处展示一个从输入到输出的完整示例）

```
用户: /brainstorm 学生登录

---

## 📖 Step 1: 解析输入参数

- 命令: brainstorm
- 参数: 学生登录
- 模块名: 学生登录
- 关键词: ["学生登录", "学生", "登录", "student", "login", "auth", "signin"]

---

## 📖 Step 2: 读取基础文档

正在读取以下文档：

### API 规范
- 文件: osg-spec-docs/docs/06-api/openapi.yaml
- 状态: ✅ 已读取
- 找到相关内容: 是
- 相关内容:
  ```yaml
  /api/student/auth/login:
    post:
      summary: 学生登录
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StudentLoginRequest'
      responses:
        '200':
          description: 登录成功
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StudentLoginResponse'
  ```

### 数据库设计
- 文件: osg-spec-docs/docs/07-database/DB-DDL-001_table-definitions.md
- 状态: ✅ 已读取
- 找到相关内容: 是
- 相关内容:
  ```sql
  CREATE TABLE osg_student (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    name VARCHAR(50) NOT NULL,
    status TINYINT DEFAULT 1,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  );
  ```

### 路由规格
- 目录: osg-spec-docs/docs/03-design/routes/
- 状态: ✅ 已读取
- 匹配文件: student-routes.ts
- 相关内容:
  ```typescript
  {
    path: '/login',
    component: () => import('@/views/login/index.vue'),
    meta: { title: '学生登录', requiresAuth: false }
  }
  ```

### 功能需求
- 目录: osg-spec-docs/docs/02-requirements/functional/
- 状态: ✅ 已读取
- 匹配文件: REQ-FUN-001-auth.md

### 类型定义
- 文件: osg-spec-docs/docs/07-database/types.ts
- 状态: ✅ 已读取
- 相关内容:
  ```typescript
  interface StudentLoginRequest {
    email: string;
    password: string;
  }
  
  interface StudentLoginResponse {
    token: string;
    student: StudentInfo;
  }
  ```

**文档读取统计**:
- 总文件数: 5
- 成功读取: 5
- 找到相关内容的文件: 5

---

## 📖 Step 3: 生成初版需求文档

[生成需求文档...]

---

## 🔍 Step 4: 正向校验 - 第 1 轮

### 检查项 1：细致度
- 检查模糊表述: 未发现
- 检查文件路径完整性: 4/4 完整
- 检查方法说明完整性: 4/4 有完整说明
- 检查代码片段: 有
- **结论**: ✅ 通过

### 检查项 2：最简路径
- 检查是否复用现有代码: 是（复用 JwtUtils）
- 检查是否有不必要的新增: 否
- **结论**: ✅ 通过

### 检查项 3：影响范围
- 检查是否列出影响模块: 是（列出 2 个模块）
- 检查是否分析依赖: 是
- **结论**: ✅ 通过

### 检查项 4：异常处理
- 检查异常场景数量: 5 个
- 需要的最小数量: 3 个
- **结论**: ✅ 通过

### 检查项 5：规范性
- 检查是否符合分层架构: 是
- 检查命名是否规范: 是
- **结论**: ✅ 通过

**正向校验结论**: ✅ 全部通过 (5/5)

---

## 🔍 Step 5: 反向校验 - 第 1 轮

### 检查项 1：用户视角
- 检查用户问题场景数量: 5 个
- 需要的最小数量: 3 个
- **结论**: ✅ 通过

### 检查项 2：测试视角
- 检查正向测试: 有 (1 个)
- 检查反向测试: 有 (2 个)
- 检查边界测试: 有 (1 个)
- **结论**: ✅ 通过

### 检查项 3：场景覆盖
- 检查用户角色覆盖: 是（仅学生角色）
- 检查批量操作: 不适用
- **结论**: ✅ 通过

### 检查项 4：代码必要性
- 检查每个文件的必要性: 是
- **结论**: ✅ 通过

### 检查项 5：冗余检查
- 检查重复逻辑: 无
- **结论**: ✅ 通过

### 检查项 6：复用检查
- 检查是否标注复用: 是（JwtUtils）
- **结论**: ✅ 通过

**反向校验结论**: ✅ 全部通过 (6/6)

---

## ✅ Step 6: Brainstorm 完成

**模块**: 学生登录
**需求文档**: osg-spec-docs/docs/12-implementation/student-login/REQ-001-student-login.md

**校验摘要**:
- 正向校验: 1 轮，全部通过 ✅
- 反向校验: 1 轮，全部通过 ✅

**下一步**: 运行 `/split story` 拆解为 Story

---

[完整的需求文档内容...]
```

---

## 相关文档

- [00_概览](00_概览.md) - 返回概览
- [11_Skills_工作流](11_Skills_工作流.md) - brainstorming 详细定义
- [40_commands_命令文件](40_commands_命令文件.md) - **其他命令的详细步骤**（/split、/approve、/status 等）
- [42_实现细节](42_实现细节.md) - 技术实现细节
- [45_平台适配与Hooks机制](45_平台适配与Hooks机制.md) - 跨平台执行步骤
