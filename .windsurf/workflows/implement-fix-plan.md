---
description: 通用变更方案生成与执行 - 支持修复/重构/新功能/文档更新（含多轮校验）
---

# 变更方案生成与执行（Implement Fix Plan）

## 使用方式

### 模式 A：已有方案文档

```
/implement-fix-plan {方案文档路径}
```

例如：`/implement-fix-plan docs/gate-control-fix-plan.md`

### 模式 B：无方案，描述问题/需求

```
/implement-fix-plan "问题或需求描述"
```

例如：`/implement-fix-plan "将 implement-fix-plan 泛化为通用方案工具"`

> 模式 B 会先执行 Phase 0（方案生成），再进入 Phase 1。

## 前置条件

- **模式 A**：方案文档已存在，包含修改项（文件、内容、优先级）
- **模式 B**：用户能清晰描述问题/需求，相关代码可访问

---

## 执行步骤

### Phase 0: 方案生成（仅模式 B）

> 如果用户提供了方案文档路径（模式 A），跳过此阶段直接进入 Phase 1。

0-1. **问题/需求分析**
   - 解析用户描述，识别变更类型（修复 / 重构 / 新功能 / 文档更新）
   - 使用 `code_search` 定位相关代码和文件
   - 理解当前实现和上下文

0-2. **影响范围评估**
   - 列出所有受影响的文件
   - 识别上下游依赖关系
   - 评估变更风险等级（高/中/低）

0-3. **生成方案**
   - 为每个需要修改的文件生成修改项：
     - 编号、文件路径、当前内容（行号）、目标内容、优先级
   - 按依赖关系排序
   - 输出完整方案（格式与模式 A 的方案文档一致）

0-4. **用户确认方案**
   - 展示生成的方案
   - ⚠️ 等待用户确认或调整后，方案固化，进入 Phase 1

### Phase 1: 读取方案 + 制定执行计划

1. **读取方案**
   - 模式 A：读取方案文档，提取所有修改项（编号、文件、内容、优先级）
   - 模式 B：使用 Phase 0 生成的方案

2. **读取所有涉及的文件**
   - 读取方案中列出的每个待修改文件的当前内容
   - 理解文件结构和上下文

3. **制定执行计划**
   - 按优先级排序（🔴高 → 🟡中 → 🟢低）
   - 识别依赖关系（哪些修改项必须先做）
   - 分批：每批包含可以同时修改的文件
   - 输出 todo list

4. **向用户确认执行计划**
   - 展示分批计划
   - 等待用户确认后开始

### Phase 2: 逐批修改

对每一批修改：

5. **展示修改方案**
   - 列出本批要修改的文件
   - 展示每个文件的具体修改内容（old → new）
   - 说明修改的影响范围
   - **同步检查清单**（根据修改文件类型选择对应模板）：

     **模板 S — Skill 文件（SKILL.md 伪代码）**：
     - [ ] 执行流程图 — 是否反映新增的 Phase/步骤？
     - [ ] 硬约束节 — 是否覆盖新增的迭代限制？
     - [ ] 迭代计数强制规则 — 格式示例是否与新代码一致？
     - [ ] 失败退出规则 — 是否覆盖所有失败路径？
     - [ ] 输出格式 — 是否包含新增的校验项？
     - [ ] 对应 Workflow 文件 — 步骤描述是否与 Skill 行为一致？

     **模板 W — Workflow 文件（.md 工作流）**：
     - [ ] 触发条件 — 状态名是否与 state-machine.yaml 一致？
     - [ ] 步骤描述 — 是否与对应 Skill 的实际行为匹配？
     - [ ] 状态更新 — current_step / next_step 是否正确？
     - [ ] 用户交互点 — 是否在需要确认的地方暂停？

     **模板 C — 配置/状态机文件（.yaml）**：
     - [ ] 状态定义 — 新增状态是否有 next_action？
     - [ ] 命令映射 — command_to_state 是否覆盖新命令？
     - [ ] 回滚规则 — 新增状态是否有回滚目标？
     - [ ] 审批配置 — 需要审批的状态是否标记 approval_required？

     **模板 G — 通用代码文件**：
     - [ ] 接口兼容 — 函数签名/参数是否与调用方一致？
     - [ ] 错误处理 — 新增路径是否有异常处理？
     - [ ] 测试覆盖 — 是否需要新增或更新测试？
     - [ ] 文档同步 — README/注释是否需要更新？

6. **等待用户确认**
   - ⚠️ 必须等用户明确确认后才能修改代码文件
   - 用户可以调整方案

7. **执行修改**
   - 使用 edit / multi_edit 工具修改文件
   - 每个文件修改后立即验证语法正确性

### Phase 3: 逐项校验（每批修改后）

8. **逐项校验**
   - 逐个检查修改后的文件
   - 对每个修改点提问：
     - 修改是否与方案一致？
     - 修改是否引入新问题？
     - 修改是否与其他文件矛盾？

### Phase 4: 全局终审（每批修改后）

9. **三维度全局终审**

   #### 维度 1: 上游一致性
   - 修改是否与方案文档完全对齐？
   - 是否有方案中的修改项被遗漏？
   - 是否有超出方案范围的修改？

   #### 维度 2: 下游可行性
   - 修改后的文件能被下游正确使用吗？
   - 状态值、函数名、字段名是否与调用方一致？
   - 是否有需要配套更新的下游文件？

   #### 维度 3: 全局完整性
   - 修改后的文件之间是否有逻辑矛盾？
   - 是否有重复代码或重复逻辑？
   - 数据流是否一致？

10. **终审发现问题的处理**

```
如果终审发现问题：
  1. 列出所有问题
  2. 提出修复方案
  3. 等待用户确认
  4. 执行修复
  5. 重新从 Phase 3（逐项校验）开始 ← 打回重来
  6. 重新执行 Phase 4（全局终审）
```

### Phase 5: 多轮校验循环

11. **循环规则**

```
loop:
  执行 Phase 3（逐项校验）
  执行 Phase 4（全局终审）
  
  if 本轮有修改:
    continue  # 有修改就必须再来一轮
  else:
    无修改轮次 += 1
    if 无修改轮次 >= 2:
      break  # 连续两轮无修改才算通过
    else:
      continue  # 再来一轮确认
```

**关键规则**：
- 每轮逐项校验必须从**不同维度**提问，不能重复同样的检查清单
- 推荐的维度轮换：
  - 第1轮：A 结构正确性（语法、编号、格式）
  - 第2轮：B 边界场景与异常处理
  - 第3轮：C 数据流一致性
  - 第4轮：D 与框架其他组件的兼容性
  - 第5轮：E 安全性与防御性编程
  - 第6轮：F 可维护性与可读性
  - 第7轮：G 语义准确性
  - 第8轮：H 交叉影响（修改项之间的关联）
  - 第9轮：I 回归风险（现有功能是否受影响）
- 当某轮校验新增或修改了修改项时，下一轮必须优先使用**维度 H（交叉影响）**检查所有受影响的关联项

### Phase 6: 完成

12. **更新 todo list**
    - 标记已完成的修改项
    - 列出遗留项（需要配套更新的下游文件等）

13. **输出完成摘要**
    - 本批修改了哪些文件
    - 修改了多少行
    - 通过了几轮校验
    - 遗留项列表

14. **继续下一批或结束**
    - 如果还有未执行的批次 → 回到 Phase 2
    - 如果全部完成 → 输出最终摘要

---

## 校验维度参考

以下维度供逐项校验时轮换使用：

| 维度 | 关注点 | 示例问题 |
|------|--------|----------|
| **A 结构正确性** | 语法、编号、格式 | Step 编号是否连续？Phase 编号是否正确？ |
| **B 边界场景** | 异常输入、空值、极端情况 | 如果列表为空会怎样？除零防护？ |
| **C 数据流** | 字段结构、状态值、参数传递 | 写入的字段和读取的字段是否一致？ |
| **D 兼容性** | 与框架其他组件的交互 | 新状态值在 state-machine 中是否存在？ |
| **E 安全性** | 防御性编程、错误处理 | 失败时是否正确回滚？是否有数据不一致风险？ |
| **F 可维护性** | 代码长度、职责单一、命名 | 函数是否过长？命名是否清晰？ |
| **G 语义准确性** | 描述与实现是否匹配 | 输出格式中的命令与实际执行的命令是否一致？ |
| **H 交叉影响** | 修改项与其他修改项/现有组件的交互 | 修改了状态 X，是否检查了所有读写 X 的地方？ |
| **I 回归风险** | 修改是否可能破坏现有功能 | 现有测试是否仍然通过？是否有未覆盖的边缘场景？ |

---

## 硬约束

### 方案生成（Phase 0）
- **禁止** 跳过影响范围评估直接生成方案
- **禁止** 未经用户确认就固化方案
- **必须** 方案中每个修改项都包含精确的行号和内容

### 执行与校验（Phase 1~6）
- **禁止** 跳过逐项校验直接做全局终审
- **禁止** 连续两轮用相同维度的问题
- **禁止** 终审发现问题后不打回重来
- **禁止** 只做一轮无修改就声明通过（必须连续两轮）
- **必须** 每次修改代码前先向用户确认
- **必须** 每批修改后都执行完整的 Phase 3 + Phase 4 + Phase 5
- **必须** 根据文件类型选择对应的同步检查清单模板（S/W/C/G）
