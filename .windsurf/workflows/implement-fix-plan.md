---
description: 通用变更方案生成与执行 - 支持修复/重构/新功能/文档更新（含多轮校验）
---

# 变更方案生成与执行（Implement Fix Plan）

## 使用方式

### 模式 A：已有方案文档

```
/implement-fix-plan {方案文档路径}
```

例如：`/implement-fix-plan docs/gate-control-fix-plan.md`

### 模式 B：无方案，描述问题/需求

```
/implement-fix-plan "问题或需求描述"
```

例如：`/implement-fix-plan "将 implement-fix-plan 泛化为通用方案工具"`

> 模式 B 会先执行 Phase 0（方案生成），再进入 Phase 1。

## 前置条件

- **模式 A**：方案文档已存在，包含修改项（文件、内容、优先级）
- **模式 B**：用户能清晰描述问题/需求，相关代码可访问

---

## 执行步骤

### Phase 0: 方案生成（仅模式 B）

> 如果用户提供了方案文档路径（模式 A），跳过此阶段直接进入 Phase 1。

0-1. **读取上下文（迭代式）**
   - a. 读取 `.claude/CLAUDE.md`（设计原则 + 禁止行为）
   - b. 根据需求关键词搜索直接相关文件，完整读取
   - c. 从已读文件中发现引用的其他文件（import/引用/配置），继续读取
   - d. 重复 c 直到没有新发现
   - e. 读取 STATE.yaml（当前项目状态，如存在）
   - f. 完整性检查 — 列出已读文件清单，确认覆盖了上游输入和下游消费者
   - → 目标：让 AI 拥有与用户同等的上下文理解

0-2. **分析 + 设计决策**
   - a. 需求分析 — 明确要做什么、为什么做、做到什么程度
   - b. 影响范围 — 列出所有受影响的文件/模块/流程 + 上下游依赖
   - c. 设计决策 — 列出关键决策点 + 每个决策的选项 + 推荐方案 + 理由
   - d. 前置条件/假设 — 显式列出所有隐含假设

0-3. **生成方案**
   - 按方案文档模板（见下方"方案文档模板"节）生成完整方案文档
   - 注意：至少"目标"和"执行清单"必须有实质内容

0-4. **自校验 + 自修正（max 3 轮）**
   - a. 选择校验标准（见下方"自校验标准"节）
   - b. 逐条校验
   - c. 发现问题 → 直接修正方案，不问用户
   - d. 修正后重新校验（优先检查修正引入的新问题，然后用不同维度）
   - e. 退出条件（先满足的生效）：
     - 某轮所有选定的校验项全部通过（通用 G1-G9 必做 + 追加项按场景选）→ 通过
     - 达到 3 轮 → 输出当前方案，未通过项标记为"⚠️ 待用户决策"
   - f. 在方案文档的"自校验结果"节记录每轮校验过程

0-5. **输出定稿方案**
   - 展示生成的方案
   - ⚠️ 等待用户确认或调整后，方案固化，进入 Phase 1

### 方案文档模板

每次生成的方案文档**必须**包含以下节（简单变更可在对应节写"无"或"不适用"，但不能省略节本身）：

```markdown
# {方案名称}

> 设计原则：一看就懂、每个节点只做一件事、出口统一、上游有问题就停、
> 最少概念、最短路径、改动自洽、简约不等于省略。

## 一、目标
- 一句话描述要做什么
- 做到什么程度（验收标准）

## 二、前置条件与假设
- 假设 1: ...
- 假设 2: ...

## 三、现状分析
- 相关文件/模块列表
- 上下游依赖关系
- 当前逻辑/流程描述
- 存在的问题

## 四、设计决策
| # | 决策点 | 选项 | 推荐 | 理由 |
|---|--------|------|------|------|
| 1 | ... | A/B/C | A | ... |

## 五、目标状态
- 整体流程图（如适用）
- 关键逻辑/伪代码（如适用）
- 关键点说明

## 六、执行清单
| # | 文件/模块 | 位置 | 当前值 | 目标值 |
|---|-----------|------|--------|--------|

## 七、自校验结果
从本工作流的「自校验标准」中选择适用的校验项，逐条填写：
| 校验项 | 通过？ | 说明 |
|--------|--------|------|
| ... | ✅/⚠️ | ... |
```

### Phase 1: 读取方案 + 制定执行计划

1. **读取方案**
   - 模式 A：读取方案文档，提取所有修改项（编号、文件、内容、优先级）。如果方案文档缺少必选节（如设计决策、自校验结果），提示用户补充。
   - 模式 B：使用 Phase 0 生成的方案

2. **读取所有涉及的文件**
   - 读取方案中列出的每个待修改文件的当前内容
   - 理解文件结构和上下文

3. **制定执行计划**
   - 按优先级排序（🔴高 → 🟡中 → 🟢低）
   - 识别依赖关系（哪些修改项必须先做）
   - 分批：每批包含可以同时修改的文件
   - 输出 todo list

4. **向用户确认执行计划**
   - 展示分批计划
   - 等待用户确认后开始

### Phase 2: 逐批修改

对每一批修改：

5. **展示修改方案**
   - 列出本批要修改的文件
   - 展示每个文件的具体修改内容（old → new）
   - 说明修改的影响范围
   - **同步检查清单**（根据修改文件类型选择对应模板）：

     **模板 S — Skill 文件（SKILL.md 伪代码）**：
     - [ ] 执行流程图 — 是否反映新增的 Phase/步骤？
     - [ ] 硬约束节 — 是否覆盖新增的迭代限制？
     - [ ] 迭代计数强制规则 — 格式示例是否与新代码一致？
     - [ ] 失败退出规则 — 是否覆盖所有失败路径？
     - [ ] 输出格式 — 是否包含新增的校验项？
     - [ ] 对应 Workflow 文件 — 步骤描述是否与 Skill 行为一致？

     **模板 W — Workflow 文件（.md 工作流）**：
     - [ ] 触发条件 — 状态名是否与 state-machine.yaml 一致？
     - [ ] 步骤描述 — 是否与对应 Skill 的实际行为匹配？
     - [ ] 状态更新 — current_step / next_step 是否正确？
     - [ ] 用户交互点 — 是否在需要确认的地方暂停？

     **模板 C — 配置/状态机文件（.yaml）**：
     - [ ] 状态定义 — 新增状态是否有 next_action？
     - [ ] 命令映射 — command_to_state 是否覆盖新命令？
     - [ ] 回滚规则 — 新增状态是否有回滚目标？
     - [ ] 审批配置 — 需要审批的状态是否标记 approval_required？

     **模板 G — 通用代码文件**：
     - [ ] 接口兼容 — 函数签名/参数是否与调用方一致？
     - [ ] 错误处理 — 新增路径是否有异常处理？
     - [ ] 测试覆盖 — 是否需要新增或更新测试？
     - [ ] 文档同步 — README/注释是否需要更新？

6. **等待用户确认**
   - ⚠️ 必须等用户明确确认后才能修改代码文件
   - 用户可以调整方案

7. **执行修改**
   - 使用 edit / multi_edit 工具修改文件
   - 每个文件修改后立即验证语法正确性

### Phase 3: 逐项校验（每批修改后）

8. **逐项校验**
   - 逐个检查修改后的文件
   - 对每个修改点提问：
     - 修改是否与方案一致？
     - 修改是否引入新问题？
     - 修改是否与其他文件矛盾？

### Phase 4: 全局终审（每批修改后）

9. **三维度全局终审**

   #### 维度 1: 上游一致性
   - 修改是否与方案文档完全对齐？
   - 是否有方案中的修改项被遗漏？
   - 是否有超出方案范围的修改？

   #### 维度 2: 下游可行性
   - 修改后的文件能被下游正确使用吗？
   - 状态值、函数名、字段名是否与调用方一致？
   - 是否有需要配套更新的下游文件？

   #### 维度 3: 全局完整性
   - 修改后的文件之间是否有逻辑矛盾？
   - 是否有重复代码或重复逻辑？
   - 数据流是否一致？

10. **终审发现问题的处理**

```
如果终审发现问题：
  1. 列出所有问题
  2. 提出修复方案
  3. 等待用户确认
  4. 执行修复
  5. 重新从 Phase 3（逐项校验）开始 ← 打回重来
  6. 重新执行 Phase 4（全局终审）
```

### Phase 5: 多轮校验循环

11. **循环规则**

```
loop:
  执行 Phase 3（逐项校验）
  执行 Phase 4（全局终审）
  
  if 本轮有修改:
    continue  # 有修改就必须再来一轮
  else:
    无修改轮次 += 1
    if 无修改轮次 >= 2:
      break  # 连续两轮无修改才算通过
    else:
      continue  # 再来一轮确认
```

**关键规则**：
- 每轮逐项校验必须从**不同维度**提问，不能重复同样的检查清单
- 推荐的维度轮换：
  - 第1轮：A 结构正确性（语法、编号、格式）
  - 第2轮：B 边界场景与异常处理
  - 第3轮：C 数据流一致性
  - 第4轮：D 与框架其他组件的兼容性
  - 第5轮：E 安全性与防御性编程
  - 第6轮：F 可维护性与可读性
  - 第7轮：G 语义准确性
  - 第8轮：H 交叉影响（修改项之间的关联）
  - 第9轮：I 回归风险（现有功能是否受影响）
- 当某轮校验新增或修改了修改项时，下一轮必须优先使用**维度 H（交叉影响）**检查所有受影响的关联项

### Phase 6: 完成

12. **更新 todo list**
    - 标记已完成的修改项
    - 列出遗留项（需要配套更新的下游文件等）

13. **输出完成摘要**
    - 本批修改了哪些文件
    - 修改了多少行
    - 通过了几轮校验
    - 遗留项列表

14. **继续下一批或结束**
    - 如果还有未执行的批次 → 回到 Phase 2
    - 如果全部完成 → 输出最终摘要

---

## 校验维度参考

以下维度供逐项校验时轮换使用：

| 维度 | 关注点 | 示例问题 |
|------|--------|----------|
| **A 结构正确性** | 语法、编号、格式 | Step 编号是否连续？Phase 编号是否正确？ |
| **B 边界场景** | 异常输入、空值、极端情况 | 如果列表为空会怎样？除零防护？ |
| **C 数据流** | 字段结构、状态值、参数传递 | 写入的字段和读取的字段是否一致？ |
| **D 兼容性** | 与框架其他组件的交互 | 新状态值在 state-machine 中是否存在？ |
| **E 安全性** | 防御性编程、错误处理 | 失败时是否正确回滚？是否有数据不一致风险？ |
| **F 可维护性** | 代码长度、职责单一、命名 | 函数是否过长？命名是否清晰？ |
| **G 语义准确性** | 描述与实现是否匹配 | 输出格式中的命令与实际执行的命令是否一致？ |
| **H 交叉影响** | 修改项与其他修改项/现有组件的交互 | 修改了状态 X，是否检查了所有读写 X 的地方？ |
| **I 回归风险** | 修改是否可能破坏现有功能 | 现有测试是否仍然通过？是否有未覆盖的边缘场景？ |

---

## 自校验标准（Phase 0 方案生成时使用）

### 通用校验（所有方案必做）

| # | 校验项 | 方法 |
|---|--------|------|
| G1 | 一看就懂 | 流程图/执行清单 5 秒内能理解走向？ |
| G2 | 目标明确 | 验收标准是否可度量？做完了怎么判断"做完了"？ |
| G3 | 假设显式 | 所有隐含假设是否都列出了？ |
| G4 | 设计决策完整 | 是否有遗漏的决策点？每个决策是否有理由？ |
| G5 | 执行清单可操作 | 每项是否有明确的文件/位置/目标值？能直接执行吗？ |
| G6 | 正向流程走读 | 从头到尾走一遍，每步有输入/处理/输出？ |
| G7 | 改动自洽 | 改了 A，所有引用 A 的地方是否都检查了？ |
| G8 | 简约不等于省略 | 是否有必要的步骤/输出/校验被省略了？ |
| G9 | 场景模拟 | 用 2~3 个真实场景走一遍方案，看是否能跑通？ |

### 涉及框架流程时追加

| # | 校验项 | 方法 |
|---|--------|------|
| F1 | 文件同步 | 改了 Skill → 检查 Workflow/Command/state-machine；反之亦然 |
| F2 | 状态一致性 | 新增/修改的状态在 state-machine.yaml 中有定义？ |
| F3 | 交叉引用 | grep 所有被修改/删除/新增的关键词，确认零残留 |

### 涉及代码修改时追加

| # | 校验项 | 方法 |
|---|--------|------|
| C1 | 根因定位 | 修复的是根因还是症状？ |
| C2 | 接口兼容 | 函数签名/参数是否与调用方一致？ |
| C3 | 回归风险 | 修改是否可能破坏现有功能？ |
| C4 | 测试覆盖 | 是否需要新增或更新测试？ |

### 涉及新功能时追加

| # | 校验项 | 方法 |
|---|--------|------|
| N1 | 需求覆盖 | 所有需求点是否都有对应的执行项？ |
| N2 | 接口设计 | 新接口是否与现有架构一致？ |
| N3 | 测试设计 | 是否有测试方案？ |

### 混合场景

一个方案可能同时涉及多种场景。**通用校验必做 + 涉及哪种追加哪种**。

---

## 硬约束

### 方案生成（Phase 0）
- **禁止** 跳过影响范围评估直接生成方案
- **禁止** 未经用户确认就固化方案
- **禁止** 方案生成时不做自校验（0-4 步骤不可跳过）
- **禁止** 自校验发现问题后不修正就输出
- **必须** 方案文档包含"自校验结果"节
- **必须** 方案文档包含"设计决策"节
- **必须** 方案中每个修改项都包含精确的位置和内容

### 执行与校验（Phase 1~6）
- **禁止** 跳过逐项校验直接做全局终审
- **禁止** 连续两轮用相同维度的问题
- **禁止** 终审发现问题后不打回重来
- **禁止** 只做一轮无修改就声明通过（必须连续两轮）
- **必须** 每次修改代码前先向用户确认
- **必须** 每批修改后都执行完整的 Phase 3 + Phase 4 + Phase 5
- **必须** 根据文件类型选择对应的同步检查清单模板（S/W/C/G）
- **必须** 逐项校验时检查"修改是否与设计决策一致"
